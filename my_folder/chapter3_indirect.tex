\section{Непрямая отрисовка} \label{ch3:indirect_draw}
Как было уже упомянуто ранее, основным способом отправки команд на графический процессор считается сбор \say{списка команд} на центральном процессоре и последующая передача получившегося \say{списка} на графический процессор. Однако современных API добавилась возможность дополнить вышеупомянутый \say{список команд} дополнительным массивом команд прямо из графического процессора. Эта технология называется непрямой отрисовкой и в DirectX 12 эту технологию реализует команда ExecuteIndirect. 

Для того чтобы воспользоваться командой ExecuteIndirect, ей необходимо передать следующие параметры:
\begin{enumerate}[1.] 
	\item \say{Сигнатуру вызова} - перечень команд которые необходимо вызвать для каждого рисуемого объекта. Обязательно должна оканчиваться командой отрисовки.
	\item Буфер из видеопамяти с параметрами (которые требует сигнатура), для каждого выводимого объекта.
	\item Количество отрисовываемых объектов (число или указатель на буфер из видеопамяти).
\end{enumerate}

Таким образом, простейший алгоритм отрисовки любого числа объектов будет выглядеть так: (\firef{alg:simpleIndirect})

\begin{algorithm} %[h]
	\SetKwFunction{algoSimpleIndirectPseudocode}{} 
	\SetKwProg{myalg}{Algorithm}{}{} %write in 2nd agrument <<Algorithm>>, <<Procedure>> etc
	\nonl\myalg{\algoSimpleIndirectPseudocode}{
		Загрузить все объекты
		
		Создать сигнатуру
		
		Создать буфер (\textit{SRVbuffer}) и сохранить в него информацию для каждого объекта (например указатель на буфер вершин) 
		
		Установить формат хранения вершин
		
		Установить формат соединения вершин
		
		Установить программу-шейдер, для отрисовки
		
		
		\For {each frame}{
			ExecuteIndirect(\textit{SRVbuffer})
		}	
	}
	\caption{Примерный псевдокод простейшего алгоритма использующего непрямую отрисовку}\label{alg:simpleIndirect}
\end{algorithm}
\FloatBarrier

Таким образом мы добились поставленной цели, и количество команд в \say{списке команд} при данном подходе действительно константно относительно числа объектов. Но на практике этот алгоритм будет работать хуже, чем традиционный. Причина в том, что традиционный подход позволяет заранее отбросить отрисовку части объектов, просто не добавив их в \say{список команд}, а данный (\firef{alg:simpleIndirect}) алгоритм не даёт такой возможности. Однако, это можно было бы исправить, если буфер с параметрами (\textit{SRVbuffer}) мог бы изменяться на каждом кадре работы приложения. Это приводит нас к следующему алгоритму (\firef{alg:IndirectWithCull})

\begin{algorithm} %[h]
	\SetKwFunction{algoIndirectWithCullPseudocode}{} 
	\SetKwProg{myalg}{Algorithm}{}{} %write in 2nd agrument <<Algorithm>>, <<Procedure>> etc
	\nonl\myalg{\algoIndirectWithCullPseudocode}{
		Загрузить все объекты
		
		Создать сигнатуру
		
		Создать буфер (\textit{SRVbuffer}) и сохранить в него информацию для каждого объекта (например указатель на буфер вершин)
		
		Cоздать буфер (\textit{UAVbuffer}), совпадающий размером с предыдущим, 
		
		Cоздать счётчик (\textit{UAVcounter}) 
		
		Установить формат хранения вершин
		
		Установить формат соединения вершин
		
		\For {each frame}{
			
			Установить программу-шейдер, для обработки команд
			
			Обнулить счётчик (\textit{UAVcounter}) 
			
			Запустить вычислительный шейдер, который скопирует из \textit{SRVbuffer} в \textit{UAVbuffer} параметры нужных команд и изменит \textit{UAVcounter} на значение равное числу скопированных команд \label{alg:IndirectWithCull:culling}
			
			Установить программу-шейдер, для отрисовки
			
			ExecuteIndirect(\textit{UAVbuffer}, \textit{UAVcounter})
		}	
	}
	\caption{Примерный псевдокод алгоритма использующего непрямую отрисовку с отбрасыванием команд}\label{alg:IndirectWithCull}
\end{algorithm}
\FloatBarrier

Отметим преимущества и недостатки описанного алгоритма(\firef{alg:IndirectWithCull}):
\begin{enumerate}[1.] 
	\item Преимущество: число вызовов отрисовки в "списке команд" всё ещё является константным, относительно числа объектов
	\item Преимущество: число вызовов отрисовки на графическом процессоре не меняется(см главу \ref{ch2:Programmable-Vertex-Pulling})
	\item Преимущество: используются стандартные буферы, а значит оптимизации программы-драйвера не перестанут работать (см главу \ref{ch2:Programmable-Vertex-Pulling})
	\item Преимущество: нет проблем с фрагментацией (см главу \ref{ch2:Programmable-Vertex-Pulling})
	\item Преимущество: проверки проводимые при определении \say{нужных} команд (см \ref{alg:IndirectWithCull:culling} на \firef{alg:IndirectWithCull}), будут происходить параллельно. А так как обычно графический процессор обладает большим числом вычислительных ядер, чем центральный процессор, предложенный алгоритм будет работать быстрее.
	\item Недостаток: невозможно установить порядок, в котором объекты будут отрисовываться.
\end{enumerate}