\chapter{ОБЗОР СУЩЕСТВУЮЩИХ РЕЩЕНИЙ} \label{ch2}
\section{Использование Geometry Instancing} \label{ch2:instancing} %название по-русски
	Когда необходио придумать что-то новое, сначала небходимо понять каким образом работает текущее. Если посмотреть на "список команд", который порождается в традиционной архитектуре для отрисовки одного объекта, то можно будет увидеть алгоритм представленный на \firef{alg:oneObject}
	\begin{algorithm} %[h]
		\SetKwFunction{algoOneObjectPseudocode}{} 
		\SetKwProg{myalg}{Algorithm}{}{} %write in 2nd agrument <<Algorithm>>, <<Procedure>> etc
		\nonl\myalg{\algoOneObjectPseudocode}{
			Установить формат хранения вершин\label{alg:oneObject:setup_vertex_format}
			
			Установить формат соединения вершин\label{alg:oneObject:setup_topology}
			
			Установить программу-шейдер, в которой написан алгоритм обработки входных данных
			
			Установить из какого буфера будут поступать вершины
			
			Установить из какого буфера будут поступать номера вершин, для соединения
			
			Установить из какого буфера брать текстуру
			
			Установить преобразование объекта
			
			Выполнить команду отрисовки
		}
		\caption{Примерный псевдокод алгоритма вывода одного объекта}\label{alg:oneObject}
	\end{algorithm}
	\FloatBarrier
	
	Нетрудно заметить, что если повторить описанный выше алгоритм для большого числа различных объектов, то они отрисуются корректно, однако некторые параметры выглядят излишними. Например, если используется только один формат хранения и соединения вершин, то нет необходимости выполнять эти(\ref{alg:oneObject:setup_vertex_format} и  \ref{alg:oneObject:setup_topology} на \firef{alg:oneObject}) команды каждый раз. При рассмотрении крайнего случая, когда выводится один и тот же объект много раз, алгоритм будет выглядеть как показано на \firef{alg:manyObject}
	
	\begin{algorithm} %[h]
		\SetKwFunction{algoManyObjectPseudocode}{} 
		\SetKwProg{myalg}{Algorithm}{}{} %write in 2nd agrument <<Algorithm>>, <<Procedure>> etc
		\nonl\myalg{\algoManyObjectPseudocode}{
			Установить формат хранения вершин
			
			Установить формат соединения вершин
			
			Установить программу-шейдер, в которой написан алгоритм обработки входных данных
			
			Установить из какого буфера будут поступать вершины
			
			Установить из какого буфера будут поступать номера вершин, для соединения
			
			Установить из какого буфера брать текстуру
			
			\For {$\forall 1 \le i \le N$\label{alg:manyObject:cycle}}{
				Установить преобразование объекта $i$

				Выполнить команду отрисовки
			}	
		}
		\caption{Примерный псевдокод алгоритма вывода множества одинаковых объектов}\label{alg:manyObject}
	\end{algorithm}
	\FloatBarrier
	
	Как можно заметить, количество команд в данном алгоритме, линейно зависит от количества объектов которые рисуются(\ref{alg:manyObject:cycle} на \firef{alg:manyObject}). Возникает желание уменьшить этот список, заменив многократные вызовы команд, одним вызовом, чтобы алгоритм выглядел как показано на \firef{alg:instancedObject}
	
	\begin{algorithm} %[h]
		\SetKwFunction{algoInstancingObjectPseudocode}{} 
		\SetKwProg{myalg}{Algorithm}{}{} %write in 2nd agrument <<Algorithm>>, <<Procedure>> etc
		\nonl\myalg{\algoInstancingObjectPseudocode}{
			Установить формат хранения вершин
			
			Установить формат соединения вершин
			
			Установить программу-шейдер, в которой написан алгоритм обработки входных данных
			
			Установить из какого буфера будут поступать вершины
			
			Установить из какого буфера будут поступать номера вершин, для соединения
			
			Установить из какого буфера брать текстуру
			
			Установить из какого буфера брать преобразования объектов
				
			Выполнить команду отрисовки N раз
		}
		\caption{Примерный псевдокод алгоритма вывода множества одинаковых объектов при помощи Geometry Instancing}\label{alg:instancedObject}
	\end{algorithm}
	\FloatBarrier
	
	Именно поддержка такого алгоритма(\firef{alg:instancedObject}) и называется Geometry Instancing, и его использование отрывает большие возможности. Например в статье Park-а\cite{park2009fast} описывается архитектура графического конвейера, позволяющего выводить большие толпы объектов, при помощи технологии Geometry Instancing (\firef{fig:park_screenshot}). Из особенностей можно отметить:
	
	\begin{enumerate}[1.]
		\item Все объекты имеют несколько типов геометрии, разнящиеся по уровню детализации(\firef{fig:park_lod})
		\item Для каждого объекта, при помощи вычислительных шейдеров, определяется уровень детализации и находится ли вообще объект в области видимости.
		\item В "списке команд" находятся команды отрисовки для каждого типа геометрии, но количество раз отрисовки (для каждого типа) указывается уже исходя из работы предыдущего вычислительного шейдера.
	\end{enumerate}
	
	\begin{figure}[ht!] 
		\center
		\includegraphics [scale=0.5] {my_folder/images//park_screenshot}
		\caption{Примеры работы приложения описанного в статье Park-а\cite{park2009fast}} 
		\label{fig:park_screenshot}  
	\end{figure}
	
	\begin{figure}[ht!] 
		\center
		\includegraphics [scale=0.5] {my_folder/images//park_lod}
		\caption{Уровни детализации, описанные в статье Park-а\cite{park2009fast}} 
		\label{fig:park_lod}  
	\end{figure}
	\FloatBarrier
	
	Основным недостатком является то, что предложенная Park-ом\cite{park2009fast} архитектура требует добавлять в "список команд" команды отрисовки для каждого выводимого типа геометрии. В случае, если на экран выводится много разных объектов, предложенная архитектура ничем не будет отличаться от традиционной.
	
\section{Использование Programmable Vertex Pulling}\label{ch2:Programmable-Vertex-Pulling} %название 
	В своей статье Ricco\cite{riccio2013introducing} предлагает способ избавиться от основной проблемы Geometry Instancing-а - отрисовки объектов с одинаковой геометрией. Для этого он предлагает сделать следующее
	\begin{enumerate}[1.]
		\item Ввести понятие "пачки" треугольников - набор из N вершин(число N задаётся на центральном процессоре).
		\item Все объекты, которые требуется вывести на экран, разделяются на "пачки".
		\item Все вершины всех объектов складываются в один большой буфер.\label{vertex_big_buffer}
		\item В вычислительном шейдере, для всех объектов определяется сколько "пачек" соответствуют каждому объекту и для каждой "пачки" записываются индексы вершин из буффера со всеми вершинами. 
		\item В "списке команд" находится лишь одна команда отрисовки, которая рисует "пачку" столько раз, сколько было решено на вычислительном шейдере.
	\end{enumerate}
	
	Такой подход уменьшает количество вызовов команд отрисовок до одной, что является впечатляющим результатом. Однако этот подход не лишён недостатков:
	\begin{enumerate}[1.]
		\item Несмотря на уменьшение количества отрисовок в "списке команд", количество вызовов отрисовки на графическом процессоре увеличивается, что может негативно сказаться на производительности. 
		\item Число N, используемое для задания размера "пачки", должно подбираться эмперически. Если сделать его слишком маленьким, то число вызовов отрисовки на графическом процессоре возрастет (см п.1). Если сделать его слишком большим, то будут отрисовываться "лишние" треугольники из "пачки".
		\item Буфер (упомянутый в пункте \ref{vertex_big_buffer} прошлого списка) создаётся не как буфер для вершин, а как буфер общего назначения. Это приводит к тому, что к нему не применяются оптимизации программы-драйвера(Например способ кеширования или разложение в видеопамяти).
		\item Из-за фрагментации, которая может происходить в видеопамяти, буфер упомянутый выше, может не поместиться в видеопамять, хотя объекты по отдельности могли бы.
	\end{enumerate}
		
	
% не рекомендуется использовать отдельную section <<введение>> после лета 2020 года
%\section{Введение} \label{ch2:intro}

%Глава посвящена более подробным примерам оформления текстово-графических объектов.

%В параграфе \ref{ch2:title-abbr} приведены примеры оформления многострочной формулы и одиночного рисунка. Параграф \ref{ch2:sec-abbr} раскрывает правила оформления перечислений и псевдокода. В параграфе \ref{ch2:sec-very-short-title} приведены примеры оформления сложносоставных рисунков, длинных таблиц, а также теоремоподобных окружений.


%\section{Название параграфа} \label{ch2:title-abbr} %название по-русски



%%%%
%%		
%%  \input{...} commands are used only to sychronize some parts of the text with the author guide. Authors are free to type the text directly in .tex-files   
%%  \input{...} комманды используются только, чтобы синхронизировать части текта с рекомендациями авторам. Авторы  вольны вносить текст непосредственно в файл главы  
%%  
% \input{my_folder/tex/eq-Galois} % пример двух выравнивания двух формул в окружении align


%На \firef{fig:spbpu-new-bld-autumn-ch2} приведёна фотография Нового научно-исследовательского корпуса СПбПУ.

%	\begin{figure}[ht] 
%	\center
%	\includegraphics [scale=0.27] {my_folder/images/spbpu_new_bld_autumn}
%	\caption{Новый научно-исследовательский корпус СПбПУ \cite{spbpu-gallery}} 
%	\label{fig:spbpu-new-bld-autumn-ch2}  
%	\end{figure}
	


	
%\section{Название параграфа} \label{ch2:sec-abbr} %название по-русски
	
%Название параграфа оформляется с помощью команды \verb|\section{...}|, название главы --- \verb|\chapter{...}|. 
	

%\subsection{Название подпараграфа} \label{ch2:subsec-title-abbr} %название по-русски


%Название подпараграфа оформляется с помощью команды  \texttt{\textbackslash{}subsection\{...\}}.


%\subsubsection{Название подподпараграфа} \label{ch2:subsubsec-title-abbr} %название по-русски
	
%Использование подподпараграфов в основной части крайне не рекомендуется. В случае использования, необходимо вынести данный номер в содержание.	
%Название подпараграфа оформляется с помощью команды  \texttt{\textbackslash{}subsubsecti\-on\{...\}}.



%\input{my_folder/tex/enumeration} % правила использования перечислений	

	
%Оформление псевдокода необходимо осуществлять с помощью пакета \verb|algorithm2e| в окружении \verb|algorithm|. Данное окружение интерпретируется в шаблоне как рисунок. Пример оформления псевдокода алгоритма приведён на \firef{alg:AlgoFDSCALING}. 
	
	
%\input{my_folder/tex/pseudocode-agl-DTestsFDScaling} % пример оформления псевдокода алгоритма 	

	
%\section{Название параграфа} \label{ch2:sec-very-short-title} %название по-русски


	
%\input{my_folder/tex/eq-equation-multilined} % пример оформления одиночной формулы в несколько строк

%\input{my_folder/tex/fig-spbpu-sc-four-in-one} % пример подключения 4х иллюстраций в одном рисунке

%\input{my_folder/tex/fig-spbpu-whitehall-three-in-one} % пример подключения 3х иллюстрации в одном рисунке
%
%\input{my_folder/tex/fig-spbpu-main-bld-two-in-one} % пример подключения 2х иллюстраций в одном рисунке

%\input{my_folder/tex/tab-more-than-one-page} % пример подключения таблицы на несколько страциц


%\begin{table} [htbp]% Пример оформления таблицы
%	\centering\small
%	\caption{Пример представления данных для сквозного примера по ВКР \cite{Peskov2004}}%
%	\label{tab:ToyCompare}		
%		\begin{tabular}{|l|l|l|l|l|l|}
%			\hline
%			$G$&$m_1$&$m_2$&$m_3$&$m_4$&$K$\\
%			\hline
%			$g_1$&0&1&1&0&1\\ \hline
%			$g_2$&1&2&0&1&1\\ \hline
%			$g_3$&0&1&0&1&1\\ \hline
%			$g_4$&1&2&1&0&2\\ \hline
%			$g_5$&1&1&0&1&2\\ \hline
%			$g_6$&1&1&1&2&2\\ \hline		
%		\end{tabular}
%	\caption*{\raggedright\hspace*{2.5em} Составлено (или/и рассчитано) по \cite{Peskov2004}} %Если проведена авторская обработка или расчеты по какому-либо источнику	
%	\normalsize% возвращаем шрифт к нормальному
%\end{table}



%% please, before using, read the author guide carefully

%\input{my_folder/tex/tab-toy-context-minipage} % пример подключения minipage

%\input{my_folder/tex/fig-spbpu-new-bld-autumn-minipage} % пример подключения minipage




%\input{my_folder/tex/rules-theorem-like-expressions} 

%По аналогии с нумерацией формул, рисунков и таблиц нумеруются и иные текстово-графические объекты, то есть включаем в нумерацию номер главы, например: теорема 3.1. для первой теоремы третьей главы монографии. Команды \LaTeX{} выставляют нумерацию и форматирование автоматически. Полный перечень команд для подготовки текстово-графических и иных объектов находится в подробных методических рекомендациях \cite{spbpu-bci-template-author-guide}. 


%\input{my_folder/tex/rules-list-of-environments} % список некоторых окружений


%\input{my_folder/tex/theorem-example} %пример оформления теоремы


%\input{my_folder/tex/definition-example} %пример оформления определения


%Вместо теоремо-подобных окружений для вставки небольших текстово-графических объектов иногда используются команды. Типичным примером такого подхода является команда \verb|\footnote{text}|\footnote{Внимание! Команда вставляется непосредственно после слова, куда вставляется сноска (без пробела). Лишние пробелы также не указываются внутри команды перед и после фигурных скобок.}, где в аргументе \verb|text| указывают текст \textit{подстрочной ссылки (сноски)}.В них \textit{нельзя добавлять веб-ссылки или цитировать литературу}. Для этих целей используется список литературы. Нумерация сносок сквозная по ВКР без точки на конце выставляется в шаблоне автоматически, однако в каждом приложении к ВКР нумерация, зависящая от номера приложения, выставляется префикс <<П>>, например <<П1.1>> --- первая сноска первого приложения. 




%\FloatBarrier % заставить рисунки и другие подвижные (float) элементы остановиться


%\section{Выводы} \label{ch2:conclusion}

%Текст заключения ко второй главе. Пример ссылок \cite{Article,Book,Booklet,Conference,Inbook,Incollection,Manual,Mastersthesis,Misc,Phdthesis,Proceedings,Techreport,Unpublished,badiou:briefings}, а также ссылок с указанием страниц, на котором отображены те или иные текстово-графические объекты  \cite[с.~96]{Naidenova2017} или в виде мультицитаты на несколько источников \cites[с.~96]{Naidenova2017}[с.~46]{Ganter1999}. Часть библиографических записей носит иллюстративный характер и не имеет отношения к реальной литературе. 

%Короткое имя каждого библиографического источника содержится в специальном файле \verb|my_biblio.bib|, расположенном в папке \verb|my_folder|. Там же находятся исходные данные, которые с помощью программы \texttt{Biber} и стилевого файла \texttt{Biblatex-GOST} \cite{ctan-biblatex-gost} приведены в списке использованных источников согласно ГОСТ 7.0.5-2008.
%Многообразные реальные примеры исходных библиографических данных можно посмотреть по ссылке \cite{ctan-biblatex-gost-examples}.

%Как правило, ВКР должна состоять из четырех глав. Оставшиеся главы можно создать по образцу первых двух и подключить с помощью команды \verb|\input| к исходному коду ВКР. Далее в приложении \ref{appendix-MikTeX-TexStudio} приведены краткие инструкции запуска исходного кода ВКР \cite{latex-miktex,latex-texstudio}.

%В приложении \ref{appendix-extra-examples} приведено подключение некоторых текстово-графических объектов. Они оформляются по приведенным ранее правилам. В качестве номера структурного элемента вместо номера главы используется <<П>> с номером главы. Текстово-графические объекты из приложений не учитываются в реферате.



%% Вспомогательные команды - Additional commands
%
%\newpage % принудительное начало с новой страницы, использовать только в конце раздела
%\clearpage % осуществляется пакетом <<placeins>> в пределах секций
%\newpage\leavevmode\thispagestyle{empty}\newpage % 100 % начало новой страницы